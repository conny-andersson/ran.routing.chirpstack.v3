from enum import Enum
from typing import Optional

import pylorawan
from pydantic import BaseModel
from ran.routing.core.domains import (
    DownstreamRadio,
    LoRaModulation,
    TransmissionWindow,
    UpstreamRadio,
    UpstreamRejectResultCode,
)


# Uplink models
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
class UplinkRadioParams(UpstreamRadio):
    pass


class Gps(BaseModel):
    lat: float
    lng: float
    alt: float | None


class Uplink(BaseModel):
    uplink_id: str
    used_mic: int
    payload: pylorawan.message.PHYPayload
    radio: UplinkRadioParams
    gps: Gps | None

    # context_id is string-represented uuid, shared between uplink and downlink, who answers this uplink
    # context_id will be uniqly generated by bridge, so we just reusing this "uplink_id" as "context_id"
    @property
    def context_id(self) -> str:
        return self.uplink_id

    class Config:
        arbitrary_types_allowed = True


class UplinkAck(BaseModel):
    uplink_id: str
    mic: int
    dev_eui: str

    @property
    def context_id(self) -> str:
        return self.uplink_id


class UplinkRejectReason(Enum):
    DeviceNotFound = 1
    MicChallengeFail = 2
    InternalError = 3
    NotSupported = 4


class UplinkReject(BaseModel):
    uplink_id: str
    reason: UplinkRejectReason

    @property
    def context_id(self) -> str:
        return self.uplink_id


# Downlink models
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
class DownlinkRadioParams(DownstreamRadio):
    pass


class DownlinkTiming:
    class TimingBase:
        pass

    class Delay(TimingBase, BaseModel):
        seconds: int

    class GpsTime(TimingBase, BaseModel):
        tmms: int

    class Immediately(TimingBase, BaseModel):
        pass

    @classmethod
    def __instancecheck__(cls, instance):
        return isinstance(instance, cls.TimingBase)


class DownlinkDeviceContext:
    class ContextBase:
        pass

    class Regular(ContextBase, BaseModel):
        dev_eui: str
        target_dev_addr: Optional[str]

    class Multicast(ContextBase, BaseModel):
        multicast_addr: str

    @classmethod
    def __instancecheck__(cls, instance):
        return isinstance(instance, cls.ContextBase)


class Downlink(BaseModel):
    downlink_id: str
    context_id: str
    payload: bytes

    radio: DownlinkRadioParams
    timing: DownlinkTiming.TimingBase
    device_ctx: Optional[DownlinkDeviceContext.ContextBase]

    class Config:
        arbitrary_types_allowed = True


class DownlinkResultStatus(Enum):
    OK = 0
    ERROR = 1
    TOO_LATE = 2


class DownlinkResult(BaseModel):
    downlink_id: str
    status: DownlinkResultStatus


__all__ = (
    # re-exporting
    "DownstreamRadio",
    "TransmissionWindow",
    "UpstreamRadio",
    "UpstreamRejectResultCode",
    "LoRaModulation",
    # Uplink
    "UplinkRadioParams",
    "Uplink",
    "UplinkAck",
    "UplinkRejectReason",
    "UplinkReject",
    # Downlink
    "DownlinkRadioParams",
    "DownlinkTiming",
    "DownlinkDeviceContext",
    "DownlinkResultStatus",
    "DownlinkResult",
)
